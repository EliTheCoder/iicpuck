const refreshRate=50;const startingX=100;const startingY=100;const friction=1.02;const ghostWait=10;let puck={id:IIC.getId(),x:startingX,y:startingY,vx:20,vy:13};let cids=[];let pos=[];limiters.click=ratelimit(rawSend,0);let ghostTimer=ghostWait;function update(){cids=IIC.getConnectedIds();cids.splice(cids.indexOf(puck.id),1);pos=cids.map(cid=>{return IIC.getPosition(cid)}).filter(a=>a);pos.forEach(a=>{if(distance(puck.x,puck.y,a.x,a.y)<30){puck.vx=puck.x-a.x;puck.vy=puck.y-a.y}});puck.x+=puck.vx;puck.y+=puck.vy;puck.vx/=friction;puck.vy/=friction;if(puck.x<0){puck.x=0;puck.vx=-puck.vx}
if(puck.x>window.innerWidth){puck.x=window.innerWidth;puck.vx=-puck.vx}
if(puck.y<0){puck.y=0;puck.vy=-puck.vy}
if(puck.y>window.innerHeight){puck.y=window.innerHeight;puck.vy=-puck.vy}
IIC.setPosition(puck.x,puck.y);IIC.makeWave(puck.x,puck.y);ghostTimer--;if(ghostTimer<=0){ghostTimer=ghostWait;IIC.makeGhost(puck.x,puck.y)}
IIC.setAngle(IIC.getAngle()+Math.PI/(180/(puck.vx+puck.vy)))}
setInterval(update,refreshRate);function distance(x1,y1,x2,y2){return Math.sqrt((x1-x2)**2+(y1-y2)**2)}
